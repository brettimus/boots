# mem: zshrc = interactive shell candy (prompt, aliases, completions, keybinds)

# Treat -, /, . as boundaries (like on macos)
export WORDCHARS='*?[]~=&;!#$%^(){}<>'

# git completion setup - expects to run after homebrew shellenv
autoload -Uz compinit
compinit

# zsh prompt setup with git support
setopt prompt_subst

# Simple git branch function that works everywhere
function git_branch_info() {
    if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
        local branch=$(git symbolic-ref --short HEAD 2>/dev/null || git describe --tags --exact-match 2>/dev/null || git rev-parse --short HEAD 2>/dev/null)
        if [[ -n "$branch" ]]; then
            echo "%F{magenta}[${branch}]%f"
        fi
    fi
}

# username shortener (optional)
short_user=$USER; [[ $USER == "brettbeutell" ]] && short_user="bb"

PROMPT="%F{cyan}${short_user}%f %F{yellow}%~%f \$(git_branch_info)
%F{green}❯%f "

# TODO - still fiddling with RPROMPT
# setopt prompt_subst
# RPROMPT='%(?..%F{red}✗ %?%f) $([[ $SECONDS -gt 1 ]] && echo "%F{blue}${SECONDS}s%f")'

# set aliases
source ~/boots/aliases.sh

# Auto-cycle through themes on shell startup (different from last time)
function auto_select_theme() {
    # Skip if running inside Cursor/VS Code (they have their own theme system)
    if [[ -n "$VSCODE_PID" ]] || [[ -n "$VSCODE_INJECTION" ]] || [[ "$TERM_PROGRAM" == "vscode" ]] || [[ "$TERM_PROGRAM" == "cursor" ]]; then
        return
    fi
    
    local themes=(
        "adventure-time"
        "github"
        "toychest"
        "dracula"
        "yellow"
        "rose-pine-moon"
        "rose-pine-dawn"
        "solarized-light"
        "solarized-dark"
    )
    
    local last_theme_file="$HOME/.last-theme"
    local last_theme=""
    local current_index=1  # Start with first theme if no last theme exists
    
    # Read last theme if file exists
    if [[ -f "$last_theme_file" ]]; then
        last_theme=$(cat "$last_theme_file")
        
        # Find the index of the last theme
        for i in {1..${#themes[@]}}; do
            if [[ "${themes[$i]}" == "$last_theme" ]]; then
                current_index=$i
                break
            fi
        done
        
        # Move to next theme (wrap around if at end)
        current_index=$((current_index + 1))
        if [[ $current_index -gt ${#themes[@]} ]]; then
            current_index=1
        fi
    fi
    
    # Select the theme at current index
    local selected_theme="${themes[$current_index]}"
    
    # Skip if theme is "rose-pine-moon" (already default)
    if [[ "$selected_theme" == "rose-pine-moon" ]]; then
        # Still save for next time to continue the cycle
        echo "$selected_theme" > "$last_theme_file"
        return
    fi
    
    # Apply the theme
    source "$HOME/boots/theme-${selected_theme}.sh"
    
    # Save for next time
    echo "$selected_theme" > "$last_theme_file"
}

# Run the auto-selection
auto_select_theme

# URL-encode helper function for Bear x-callback URLs
urlencode() {
  python3 -c "import sys, urllib.parse; print(urllib.parse.quote(sys.stdin.read(), safe=''))"
}

# Open markdown file in Bear with #terminal tag
function bear() {
  if [ -z "$1" ]; then
    echo "Usage: bear path/to/file.md" >&2
    return 1
  fi

  local file="$1"

  if [ ! -f "$file" ]; then
    echo "No such file: $file" >&2
    return 1
  fi

  local title
  title=$(basename "$file")

  local encoded_title
  encoded_title=$(printf %s "$title" | urlencode)

  local encoded_text
  encoded_text=$(cat "$file" | urlencode)

  # Debug: show what we're sending (first 100 chars of encoded text)
  # echo "Title: $title" >&2
  # echo "Encoded title length: ${#encoded_title}" >&2
  # echo "Encoded text length: ${#encoded_text}" >&2
  # echo "First 100 chars of encoded text: ${encoded_text:0:100}..." >&2

  local url="bear://x-callback-url/create?title=${encoded_title}&text=${encoded_text}&tags=terminal"

  # Debug: show URL length
  # echo "URL length: ${#url}" >&2

  open "$url"
}

# bun completions (temporarily commented out because it was causing issues with my PROMPT)
# [ -s "/Users/brettbeutell/.bun/_bun" ] && source "/Users/brettbeutell/.bun/_bun"

